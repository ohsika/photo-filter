import streamlit as st
from PIL import Image, ImageOps, ImageFilter
import numpy as np
import os
import io
import zipfile
import tempfile
import shutil
import gc
import math # í•„í„° ìƒì„±ì„ ìœ„í•œ ìˆ˜í•™ ëª¨ë“ˆ

# --- í˜ì´ì§€ ì„¤ì • ---
st.set_page_config(page_title="CAMPSMAP Pro", page_icon="ğŸ“¸", layout="wide")

st.markdown("""
<style>
    div[data-testid="stImage"] { border-radius: 8px; overflow: hidden; }
    .stButton>button { border-radius: 8px; }
    div.stButton { margin-top: 10px; }
</style>
""", unsafe_allow_html=True)

# --- í•„í„° ì„¤ëª… ---
FILTER_DESCRIPTIONS = {
    # ë² ì´ì§
    "Classic": "í‘œì¤€ í•„ë¦„", "Vintage": "ë”°ëœ»í•œ ë¹ˆí‹°ì§€", "Mono": "ë¶€ë“œëŸ¬ìš´ í‘ë°±",
    "Kino": "ì˜í™” ìƒ‰ê°", "Kodaclone": "ì½”ë‹¥ ìŠ¤íƒ€ì¼", "101Clone": "ë„ì‹œì  ê°ì„±",
    "Art-Club": "ëª½í™˜ì  ë³´ë¼", "Boom-Boom": "ê°•ë ¬í•œ ì±„ë„", "Bubblegum": "í•‘í¬ íŒŒìŠ¤í…”",
    "Cross-Pross": "ì²­ë¡ìƒ‰ í‹´íŠ¸", "Eternia": "ë¬¼ ë¹ ì§„ ê°ì„±", "Grunge": "ê±°ì¹œ ë½ì‹œí¬",
    "Midas": "í™©ê¸ˆë¹› ë…¸ì„", "Narnia": "ê²¨ìš¸ íŒíƒ€ì§€", "Pastel": "ìˆœí•œ ë´„",
    "Pistachio": "ì‹±ê·¸ëŸ¬ìš´ ë…¹ìƒ‰", "Temporum": "ì„¸í”¼ì•„ ì¶”ì–µ", "Uddh": "ëŒ€ì§€ì˜ ìƒ‰",
    "X-Pro": "ê°•í•œ ëŒ€ë¹„", "Black_And_White": "ê°•í•œ í‘ë°±", "Bleach": "ë¬µì§í•œ í†¤",
    # íŠ¸ë Œë”” (ëŠì¢‹)
    "Sinsa_Mood": "ì„±ìˆ˜/ì‹ ì‚¬ ë§¤íŠ¸í•œ í†¤",
    "Hannam_Chic": "ì„¸ë ¨ëœ í™”ì´íŠ¸",
    "Fuji_Air": "í›„ì§€í•„ë¦„ ê³µê¸°ê°",
    "Leica_Mono": "ê¹Šì€ ë¼ì´ì¹´ í‘ë°±",
    "Cinestill_Night": "í‘¸ë¥¸ ë°¤ ê°ì„±",
    "Portrait_Soft": "ì¸ë¬¼ í”¼ë¶€í†¤ ë³´ì •",
}

# -------------------------------------------------------------------
# [Admin] í•„í„° íŒŒì¼ ìƒì„±ê¸° (ì½”ë“œë¡œ í•„í„°ë¥¼ ë§Œë“¤ì–´ì„œ ZIPìœ¼ë¡œ ì¤Œ)
# -------------------------------------------------------------------
def generate_filter_zip():
    zip_buffer = io.BytesIO()
    
    # ì»¤ë¸Œ í•¨ìˆ˜ë“¤
    def curve_s(x, intensity=0.04): return 255 / (1 + math.exp(-intensity * (x - 128)))
    def curve_lift(x, amount=20): return min(255, x + (255-x) * 0.0 + amount * (1 - x/255))
    x_val = list(range(256))
    
    # í•„í„° ë ˆì‹œí”¼ (ì´ë¦„, R, G, B)
    recipes = {
        "Classic": ([curve_s(x, 0.04) for x in x_val], [curve_s(x, 0.04) for x in x_val], [curve_s(x, 0.04) for x in x_val]),
        "Vintage": ([curve_s(x) * 1.1 + 10 for x in x_val], [curve_s(x) * 1.0 + 5 for x in x_val], [curve_s(x) * 0.9 for x in x_val]),
        "Mono": ([curve_s(x, 0.05) for x in x_val], [curve_s(x, 0.05) for x in x_val], [curve_s(x, 0.05) for x in x_val]),
        "Kino": ([x if x < 128 else x * 1.1 for x in x_val], [x for x in x_val], [x * 1.1 if x < 128 else x * 0.9 for x in x_val]),
        "Kodaclone": ([x * 1.05 for x in x_val], [x * 1.02 for x in x_val], [x * 0.95 for x in x_val]),
        "Sinsa_Mood": ([curve_s(x, 0.03) * 1.05 for x in x_val], [curve_s(x, 0.03) * 1.02 for x in x_val], [curve_s(x, 0.03) * 0.9 + 10 for x in x_val]),
        "Hannam_Chic": ([curve_s(x, 0.05) * 0.95 for x in x_val], [curve_s(x, 0.05) for x in x_val], [curve_s(x, 0.05) * 1.1 for x in x_val]),
        "Fuji_Air": ([x * 0.95 for x in x_val], [curve_s(x, 0.04) * 1.05 for x in x_val], [x * 1.1 + 5 for x in x_val]),
        "Leica_Mono": ([255 / (1 + math.exp(-0.06 * (x - 128))) for x in x_val], [255 / (1 + math.exp(-0.06 * (x - 128))) for x in x_val], [255 / (1 + math.exp(-0.06 * (x - 128))) for x in x_val]),
        "Cinestill_Night": ([x * 0.8 if x < 100 else x * 1.2 for x in x_val], [x * 1.05 for x in x_val], [x * 1.2 if x < 100 else x * 0.8 for x in x_val]),
        "Portrait_Soft": ([x + 15 if 50 < x < 200 else x for x in x_val], [x + 5 if 50 < x < 200 else x for x in x_val], [x for x in x_val]),
    }

    with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
        for name, (r, g, b) in recipes.items():
            r = [min(255, max(0, int(v))) for v in r]
            g = [min(255, max(0, int(v))) for v in g]
            b = [min(255, max(0, int(v))) for v in b]
            
            content = f"Filter Data\nGenerated by CAMPSMAP\nRGB\n{', '.join(map(str, r))}\n{', '.join(map(str, g))}\n{', '.join(map(str, b))}\n"
            zip_file.writestr(f"{name}.flt", content)
            
    return zip_buffer.getvalue()

# --- í•„í„° ë¡œë”© ---
@st.cache_data
def load_filters():
    filters = {}
    current_dir = os.path.dirname(os.path.abspath(__file__))
    possible_paths = [
        os.path.join(current_dir, "Filters"),
        os.path.join(current_dir, "web_app", "Filters"),
        "Filters"
    ]
    
    for filter_dir in possible_paths:
        if not os.path.exists(filter_dir): continue
        try:
            files = [f for f in os.listdir(filter_dir) if f.lower().endswith(('.fit', '.flt'))]
            for fname in files:
                f_name = os.path.splitext(fname)[0]
                if f_name in filters: continue
                with open(os.path.join(filter_dir, fname), 'r', encoding='utf-8', errors='ignore') as f:
                    lines = f.readlines()
                if len(lines) < 7: continue
                lut = []
                for i in range(4, 7):
                    line_data = [int(x) for x in lines[i].replace(',', ' ').split() if x.strip().isdigit()]
                    lut.extend(line_data)
                if len(lut) < 768: lut += [lut[-1]] * (768 - len(lut))
                else: lut = lut[:768]
                filters[f_name] = lut
        except: pass
    return filters

# --- ì´ë¯¸ì§€ ì²˜ë¦¬ ---
def process_base_image(image_input, rotation=0, width=None):
    if isinstance(image_input, bytes):
        img = Image.open(io.BytesIO(image_input))
    else:
        img = image_input

    img = ImageOps.exif_transpose(img) 
    
    if rotation != 0:
        img = img.rotate(rotation, expand=True)
    
    if width:
        w_percent = (width / float(img.size[0]))
        h_size = int((float(img.size[1]) * float(w_percent)))
        img = img.resize((width, h_size), Image.Resampling.LANCZOS)
    
    # ë‚´ì¶”ëŸ´ í•„ë¦„ ë£© ì„¤ì • (ë¸”ëŸ¬ 0.1 / ë¹„ë„¤íŒ… 0.25 / ë…¸ì´ì¦ˆ 6)
    base = img.filter(ImageFilter.GaussianBlur(0.1))
    
    w, h = base.size
    x = np.linspace(-1, 1, w).astype(np.float32)
    y = np.linspace(-1, 1, h).astype(np.float32)
    X, Y = np.meshgrid(x, y)
    radius = np.sqrt(X**2 + Y**2)
    mask = 1 - np.clip(r
